from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import json
import asyncio
import time
import os
from typing import Dict, List, Optional, Set
from pydantic import BaseModel
from datetime import datetime
import uuid
import numpy as np
import logging
import zmq
import threading
import queue
from binascii import unhexlify
import scipy.signal
import io
import wave

# ================= Logging & Constants =================
LOG_NAME = "RealtimeListening"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
)
log = logging.getLogger(LOG_NAME)

IP_WHITE_LIST: List[str] = []  # 动态白名单, 初始为空, 通过 /whitelist/register 添加
PRINT_EVERY = 20

FORCE_LISTENING_DEBUG = os.getenv("FORCE_LISTENING_DEBUG", "0").lower() in {"1", "true", "yes", "on"}

# ================= ASR Model Configuration =================
# 使用非流式单次识别模型; 采用固定 revision 避免 latest 变动
MODEL_NAME = "paraformer-zh"
# 与脚本一致使用明确 revision，避免 latest 不存在导致失败
MODEL_REV = "v2.0.4"
# 启动时自动检测 GPU 可用性
try:
    import torch  # noqa
    DEVICE = "cuda:0" if torch.cuda.is_available() else "cpu"
except Exception:
    DEVICE = "cpu"

# chunk / stride parameters (placeholders adjustable to real model spec)
CHUNK_SIZE = 16000  # 1s at 16kHz
STRIDE_SIZE = 1600   # 0.1s frame stride
ENC_LB = 0
DEC_LB = 0
BYTES_PER_FRAME = 3200  # 1600 samples * 2 bytes (int16) when applicable

asr_funasr_model = None  # 模型对象占位（后续需实际加载）

# ================= Logging & Constants =================
# ...


def load_funasr_model():
    """加载 FunASR 模型（惰性加载），成功返回全局模型对象。"""
    global asr_funasr_model
    if asr_funasr_model is not None:
        return asr_funasr_model
    try:
        rt_event("asr_model_loading_start", model=MODEL_NAME, rev=MODEL_REV, device=DEVICE)
        import os
        os.environ.setdefault("USE_TORCH", "1")
        from funasr import AutoModel
        asr_funasr_model = AutoModel(
            model=MODEL_NAME,
            model_revision=MODEL_REV,
            vad_model="fsmn-vad",
            vad_model_revision="v2.0.4",
            punc_model="ct-punc",
            punc_model_revision="v2.0.4",
            device=DEVICE,
        )
        rt_event("asr_model_loaded", model=MODEL_NAME, device=DEVICE)
    except Exception as e:
        rt_event("asr_model_load_failed", error=str(e))
        asr_funasr_model = None
    return asr_funasr_model

 # startup_event 将在 app 定义后再声明

def rt_event(event: str, **fields):
    """结构化事件日志 (单行 JSON)，便于后期集中检索。
    示例: rt_event("asr_result", peer_ip="1.2.3.4", text_len=5)
    """
    payload = {"evt": event, "ts": datetime.utcnow().isoformat() + "Z", **fields}
    try:
        log.info("RT " + json.dumps(payload, ensure_ascii=False))
    except Exception:
        log.info(f"RT {{'evt':'{event}','error':'log_serialize_failed'}}")

if FORCE_LISTENING_DEBUG:
    rt_event('force_listening_debug_enabled')

# ================= FastAPI App =================
app = FastAPI(title="Voice Chat Backend", version="2.0.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    """应用启动时预加载 ASR 模型，避免首次WS建立才去加载造成延迟。"""
    load_funasr_model()
    if asr_funasr_model is None:
        rt_event("asr_model_unavailable_startup")
        return
    rt_event("asr_model_ready_startup")
    ensure_zmq_thread_started()
    ensure_broadcast_loop_started(reason='startup')


# ================= Chat Data Models & Sample Data =================
class ChatMessage(BaseModel):
    id: str
    speaker: str
    content: str
    timestamp: datetime

class ChatSession(BaseModel):
    id: str
    title: str
    status: str  # active / ended
    created_at: datetime
    ended_at: Optional[datetime] = None
    messages: List[ChatMessage] = []

# 全局存储
chat_sessions: Dict[str, ChatSession] = {}
user_chat_history: Dict[str, List[str]] = {}
active_connections: Dict[str, WebSocket] = {}

def init_sample_data():
    """初始化一些演示聊天数据，避免API调用时报空。"""
    if chat_sessions:
        return  # 已初始化
    demo_chat_id = "chat_demo_001"
    now = datetime.utcnow()
    msg1 = ChatMessage(id=uuid.uuid4().hex[:8], speaker="user", content="你好，这是一个示例对话。", timestamp=now)
    msg2 = ChatMessage(id=uuid.uuid4().hex[:8], speaker="assistant", content="你好，我在，这是一条示例回复。", timestamp=now)
    session = ChatSession(
        id=demo_chat_id,
        title="示例会话",
        status="active",
        created_at=now,
        messages=[msg1, msg2]
    )
    chat_sessions[demo_chat_id] = session
    user_chat_history.setdefault("user_001", []).append(demo_chat_id)
    rt_event("sample_data_initialized", chat_count=len(chat_sessions))
# 立即初始化示例数据
init_sample_data()

@app.get("/")
async def root():
    """根端点"""
    return {
        "message": "Voice Chat Backend with ASR Service",
        "status": "healthy",
        "asr_model": MODEL_NAME,
        "endpoints": {
            "chat_list": "/chat/list?id=user_001",
            "chat_detail": "/chat/{chat_id}",
            "websocket_chat": "/chatting?id=chat_id",
            "websocket_realtime_listening": "/listening",
            "health": "/health",
            "asr_info": "/asr/info"
        },
        "version": "2.0.0"
    }

@app.get("/health")
async def health_check():
    """健康检查端点"""
    return {
        "status": "healthy",
        "asr_available": True,  # FunASR是必选的
        "active_connections": len(active_connections),
        "total_chats": len(chat_sessions),
        "timestamp": datetime.now().isoformat()
    }

@app.get("/whitelist/register")
async def whitelist_register(request: Request = None, ip: Optional[str] = None):  # type: ignore
    """注册请求来源IP到白名单。可显式传 ip，否则取 request.client.host"""
    try:
        real_ip = ip
        if real_ip is None and request is not None and request.client:
            real_ip = request.client.host
        if real_ip and real_ip not in IP_WHITE_LIST:
            IP_WHITE_LIST.append(real_ip)
            rt_event('whitelist_added', ip=real_ip, total=len(IP_WHITE_LIST))
        return {'whitelist': IP_WHITE_LIST, 'added': real_ip}
    except Exception as e:
        return {'error': str(e), 'whitelist': IP_WHITE_LIST}

@app.get("/asr/info")
async def asr_info():
    """ASR服务信息端点"""
    return {
        "status": "available",
        "model": MODEL_NAME,
        "model_revision": MODEL_REV,
        "device": DEVICE,
        "chunk_size": CHUNK_SIZE,
        "stride_size": STRIDE_SIZE,
        "bytes_per_frame": BYTES_PER_FRAME
    }

@app.get("/debug/clients")
async def debug_clients():
    """调试端点：查看当前连接的客户端和IP映射"""
    return {
        "total_clients": len(LISTENING_CLIENTS),
        "client_ip_mapping": CLIENT_IP_MAPPING,
        "whitelist": IP_WHITE_LIST,
        "timestamp": datetime.now().isoformat()
    }

# 启动时初始化数据
# init_sample_data()  # 移到文件末尾

@app.get("/chat/list")
async def get_chat_list(id: str):
    """
    获取指定用户ID的所有聊天历史
    
    Args:
        id: 用户ID
        
    Returns:
        包含该用户所有chatId的列表
    """
    try:
        if id not in user_chat_history:
            return {"user_id": id, "chat_ids": []}
        
        chat_ids = user_chat_history[id]
        
        # 获取每个聊天的详细信息
        chat_list = []
        for chat_id in chat_ids:
            if chat_id in chat_sessions:
                session = chat_sessions[chat_id]
                chat_info = {
                    "chat_id": chat_id,
                    "title": session.title,
                    "status": session.status,
                    "created_at": session.created_at.isoformat(),
                    "ended_at": session.ended_at.isoformat() if session.ended_at else None,
                    "message_count": len(session.messages)
                }
                chat_list.append(chat_info)
        
        return {
            "user_id": id,
            "chat_list": chat_list
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取聊天列表失败: {str(e)}")

@app.get("/chat/{chat_id}")
async def get_chat_detail(chat_id: str):
    """
    获取指定聊天的详细信息和消息历史
    
    Args:
        chat_id: 聊天ID
        
    Returns:
        聊天的详细信息和消息列表
    """
    try:
        if chat_id not in chat_sessions:
            raise HTTPException(status_code=404, detail="聊天记录不存在")
        
        session = chat_sessions[chat_id]
        return {
            "chat_id": chat_id,
            "title": session.title,
            "status": session.status,
            "created_at": session.created_at.isoformat(),
            "ended_at": session.ended_at.isoformat() if session.ended_at else None,
            "messages": [
                {
                    "id": msg.id,
                    "speaker": msg.speaker,
                    "content": msg.content,
                    "timestamp": msg.timestamp.isoformat()
                }
                for msg in session.messages
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取聊天详情失败: {str(e)}")

@app.websocket("/chatting")
async def chatting_websocket(websocket: WebSocket, id: str):
    """
    WebSocket端点，用于实时聊天
    
    Args:
        id: 聊天ID
    """
    # 直接接受WebSocket连接，不检查聊天状态
    await websocket.accept()
    active_connections[id] = websocket
    
    print(f"WebSocket连接已建立: 聊天ID={id}")
    
    # 发送欢迎消息
    await websocket.send_text(json.dumps({
        "type": "connection_established",
        "chat_id": id,
        "message": "已连接到聊天会话",
        "timestamp": datetime.now().isoformat()
    }))
    
    try:
        # 监听客户端消息
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            if message_data.get("type") == "ping":
                # 响应心跳
                await websocket.send_text(json.dumps({
                    "type": "pong",
                    "timestamp": datetime.now().isoformat()
                }))
            elif message_data.get("type") == "end_chat":
                # 结束聊天
                await websocket.send_text(json.dumps({
                    "type": "chat_ended",
                    "chat_id": id,
                    "message": "聊天已结束",
                    "timestamp": datetime.now().isoformat()
                }))
                break
                
    except WebSocketDisconnect:
        print(f"WebSocket连接断开: 聊天ID={id}")
    except Exception as e:
        print(f"WebSocket错误: {e}")
    finally:
        # 清理连接
        if id in active_connections:
            del active_connections[id]


def _extract_asr_text(result):
    """从ModelScope pipeline结果中提取文本"""
    log.debug(f"ASR结果类型: {type(result)}, 内容: {result}")
    
    if not result:
        log.debug("ASR结果为空")
        return None
    
    # ModelScope pipeline返回格式: [{"value": "识别的文本"}]
    if isinstance(result, list) and result:
        log.debug(f"ASR结果是列表，长度: {len(result)}")
        item = result[0]
        log.debug(f"列表第一项类型: {type(item)}, 内容: {item}")
        
        if isinstance(item, dict):
            log.debug(f"字典键: {list(item.keys())}")
            # ModelScope格式主要是 "value" 键
            for key in ("value", "text", "transcript", "result", "sentence"):
                if key in item and item[key]:
                    text = item[key].strip()
                    if text:  # 确保文本不为空
                        log.debug(f"从键'{key}'提取到文本: '{text}'")
                        return text
            log.debug("字典中未找到有效文本")
        elif isinstance(item, str):
            text = item.strip()
            if text:
                log.debug(f"列表第一项是字符串: '{text}'")
                return text
    elif isinstance(result, str):
        text = result.strip()
        if text:
            log.debug(f"ASR结果是字符串: '{text}'")
            return text
    
    log.debug("未能从ASR结果中提取文本")
    return None

def _decode_audio_data(hex_data):
    """从hex字符串解码WAV文件数据并提取音频采样"""
    try:
        # 将hex字符串转换为字节（这是完整的WAV文件数据）
        wav_bytes = unhexlify(hex_data)
        
        # 使用BytesIO创建内存文件对象
        wav_io = io.BytesIO(wav_bytes)
        
        # 打开WAV文件
        with wave.open(wav_io, 'rb') as wav_file:
            # 获取WAV文件参数
            sample_rate = wav_file.getframerate()
            n_channels = wav_file.getnchannels()
            sample_width = wav_file.getsampwidth()
            n_frames = wav_file.getnframes()
            
            log.debug(f"WAV参数: 采样率={sample_rate}Hz, 声道={n_channels}, 位深={sample_width*8}bit, 帧数={n_frames}")
            
            # 读取音频数据
            audio_bytes = wav_file.readframes(n_frames)
            
            # 转换为numpy数组
            if sample_width == 1:
                audio_data = np.frombuffer(audio_bytes, dtype=np.uint8)
                audio_data = (audio_data.astype(np.float32) - 128) / 128.0
            elif sample_width == 2:
                audio_data = np.frombuffer(audio_bytes, dtype=np.int16)
                audio_data = audio_data.astype(np.float32) / 32768.0
            else:
                raise ValueError(f"不支持的位深: {sample_width*8}bit")
            
            # 如果是立体声，取平均值转为单声道
            if n_channels == 2:
                audio_data = audio_data.reshape(-1, 2).mean(axis=1)
            elif n_channels > 2:
                raise ValueError(f"不支持的声道数: {n_channels}")
            
            return audio_data, sample_rate
            
    except Exception as e:
        log.error(f"解码WAV数据失败: {e}")
        return None, None

def _resample_audio(audio_data, orig_sr, target_sr):
    """音频重采样"""
    if orig_sr == target_sr:
        return audio_data
    
    try:
        # 使用scipy进行重采样
        resampled = scipy.signal.resample_poly(audio_data, target_sr, orig_sr)
        log.debug(f"音频重采样: {orig_sr}Hz -> {target_sr}Hz, 长度: {len(audio_data)} -> {len(resampled)}")
        return resampled.astype(np.float32)
    except Exception as e:
        log.error(f"音频重采样失败: {e}")
        return None

# (去重) 下方原重复 IP_WHITE_LIST/PRINT_EVERY 定义已移除，保持顶部统一配置

#############################################
# 全局监听：单例 ZMQ + ASR 线程 & 广播机制
#############################################
LISTENING_CLIENTS: Dict[str, WebSocket] = {}
CLIENT_IP_MAPPING: Dict[str, str] = {}  # client_id -> client_ip 映射
ZMQ_THREAD: Optional[threading.Thread] = None
ZMQ_THREAD_STOP = threading.Event()
ZMQ_QUEUE: "queue.Queue[dict]" = queue.Queue(maxsize=1000)
SEQ_COUNTER = 0
CALL_STATE = {}  # (peer_ip, source) -> {call_id:int, buffer:bytearray, chunks:int, bytes:int}
CALL_ID_PER_SOURCE = {}
# 广播协程任务句柄（避免用线程枚举检测）
BROADCAST_TASK: Optional[asyncio.Task] = None
# Active IP lock for FORCE_LISTENING_DEBUG mode
FORCE_DEBUG_ACTIVE_IP: Optional[str] = None

# === 增量分句流式识别状态 ===
# key: (peer_ip, source, call_id) -> state dict
INCREMENTAL_STREAM_STATE: Dict[tuple, dict] = {}

def _new_segment_state():
    return {
        'segment_id': uuid.uuid4().hex[:10],  # 当前句子ID
        'stable_text': '',     # 已稳定前缀
        'pending_text': '',    # 易变后缀
        'last_full_text': '',  # 上一次模型返回全文(用于diff)
        'last_emit_text': '',  # 上一次发送给前端的全文
        'revision': -1,        # 已发送修订号
        'created_ts': time.time(),
        'last_update_ts': time.time(),
    }

BOUNDARY_PUNCT = set(list("。！？!?;；，,、."))  # 用于回退边界

def _longest_common_prefix(a: str, b: str) -> int:
    m = min(len(a), len(b))
    i = 0
    while i < m and a[i] == b[i]:
        i += 1
    return i

def _boundary_backtrack(text: str) -> int:
    """在 text 尾部回退到安全边界(标点或长度阈值)"""
    if not text:
        return 0
    # 优先寻找最右侧标点
    for i in range(len(text)-1, -1, -1):
        if text[i] in BOUNDARY_PUNCT:
            return i+1
    # 若无标点且长度>15 视作全部稳定
    if len(text) > 15:
        return len(text)
    return 0

def _process_incremental(peer_ip: str, source: str, call_id: int, new_text: str):
    """根据新文本产生增量/修订事件字典或 None (不发送)。"""
    key = (peer_ip, source, call_id)
    st = INCREMENTAL_STREAM_STATE.get(key)
    if st is None:
        st = _new_segment_state()
        INCREMENTAL_STREAM_STATE[key] = st
    st['last_update_ts'] = time.time()
    old_model_full = st['last_full_text']
    if new_text == old_model_full:
        return None
    # 计算与旧全文公共前缀
    lcp_len = _longest_common_prefix(old_model_full, new_text)
    # 在公共前缀基础上做边界回退
    boundary = _boundary_backtrack(new_text[:lcp_len])
    stable_prefix = new_text[:boundary]
    pending = new_text[boundary:]
    # 若 stable_prefix 比已有稳定多 -> 更新
    st['stable_text'] = stable_prefix
    st['pending_text'] = pending
    st['last_full_text'] = new_text
    full_emit = stable_prefix + pending
    if full_emit == st['last_emit_text']:
        return None
    st['revision'] += 1
    st['last_emit_text'] = full_emit
    evt = {
        'evt': 'asr_incremental',
        'peer_ip': peer_ip,
        'source': source,
        'call_id': call_id,
        'segmentId': st['segment_id'],
        'revision': st['revision'],
        'text': full_emit,
        'stable_len': len(stable_prefix),
        'is_final': False,
        'wall_ts': datetime.utcnow().isoformat()+'Z'
    }
    return evt

def _finalize_segment(peer_ip: str, source: str, call_id: int):
    key = (peer_ip, source, call_id)
    st = INCREMENTAL_STREAM_STATE.get(key)
    if not st:
        return None
    if st['last_emit_text'] == '':
        # 空段直接丢弃
        INCREMENTAL_STREAM_STATE[key] = _new_segment_state()
        return None
    # 发送最终事件
    st['revision'] += 1
    final_evt = {
        'evt': 'asr_incremental',
        'peer_ip': peer_ip,
        'source': source,
        'call_id': call_id,
        'segmentId': st['segment_id'],
        'revision': st['revision'],
        'text': st['last_emit_text'],
        'stable_len': len(st['last_emit_text']),
        'is_final': True,
        'wall_ts': datetime.utcnow().isoformat()+'Z'
    }
    # 重置新段
    INCREMENTAL_STREAM_STATE[key] = _new_segment_state()
    return final_evt

def _next_call_id(peer_ip, source):
    key = (peer_ip, source)
    CALL_ID_PER_SOURCE[key] = CALL_ID_PER_SOURCE.get(key, 1)
    return CALL_ID_PER_SOURCE[key]

def _rotate_call(peer_ip, source):
    key = (peer_ip, source)
    CALL_ID_PER_SOURCE[key] = CALL_ID_PER_SOURCE.get(key, 1) + 1
    return CALL_ID_PER_SOURCE[key]

def _asr_generate_blocking(pcm_bytes: bytes):
    # 同步函数供线程调用
    try:
        audio_8k = np.frombuffer(pcm_bytes, dtype=np.int16)
        if audio_8k.size == 0:
            return None
        if np.abs(audio_8k).mean() < 5:
            return None
        audio_16k = scipy.signal.resample_poly(audio_8k, up=2, down=1).astype(np.float32) / 32768.0
        result = asr_funasr_model.generate(input=audio_16k)
        if result and len(result) > 0:
            txt = result[0].get('text')
            if txt and txt.strip():
                return txt.strip()
    except Exception as e:
        log.error(f"ASR 同步生成失败: {e}")
    return None

def _next_call_id_and_inc(peer_ip, source):
    """返回下一 call_id 并立即自增，确保每个 chunk 使用不同的 call_id"""
    key = (peer_ip, source)
    val = CALL_ID_PER_SOURCE.get(key, 0) + 1
    CALL_ID_PER_SOURCE[key] = val
    return val

def _zmq_worker_thread():
    if asr_funasr_model is None:
        rt_event("zmq_thread_model_unavailable")
        return
    ctx = zmq.Context.instance()
    sock = ctx.socket(zmq.PULL)
    sock.setsockopt(zmq.LINGER, 0)
    endpoint = "tcp://0.0.0.0:5556"
    try:
        sock.bind(endpoint)
        rt_event("zmq_thread_bind", endpoint=endpoint)
    except Exception as e:
        rt_event("zmq_thread_bind_error", error=str(e))
        return
    global SEQ_COUNTER
    while not ZMQ_THREAD_STOP.is_set():
        try:
            try:
                meta_raw, pcm = sock.recv_multipart(flags=zmq.NOBLOCK)
            except zmq.Again:
                time.sleep(0.01)
                continue
            meta = json.loads(meta_raw.decode('utf-8'))
            peer_ip = meta.get('peer_ip', 'unknown')
            rt_event("peer_ip:", peer_ip)
            if IP_WHITE_LIST and IP_WHITE_LIST != ["*"] and peer_ip not in IP_WHITE_LIST and FORCE_LISTENING_DEBUG:
                rt_event('force_whitelist_override', peer_ip=peer_ip)
            source = meta.get('source', 'unknown')
            start_ts = meta.get('start_ts')
            end_ts = meta.get('end_ts')
            is_finished = bool(meta.get('IsFinished', False))
            key = (peer_ip, source)
            st = CALL_STATE.get(key)
            if st is None:
                st = {
                    'call_id': _next_call_id(peer_ip, source),
                    'buffer': bytearray(),
                    'chunks': 0,
                    'bytes': 0,
                    'first_ts': start_ts,
                }
                CALL_STATE[key] = st
            if pcm:
                st['buffer'].extend(pcm)
                st['chunks'] += 1
                st['bytes'] += len(pcm)
                SEQ_COUNTER += 1
                txt = _asr_generate_blocking(pcm)
                if txt:
                    # 每个 chunk 独立处理：分配递增的 call_id 并发送最终结果
                    rt_event("asr result:", txt)
                    call_id = _next_call_id_and_inc(peer_ip, source)
                    evt = {
                        'evt': 'asr_result',
                        'peer_ip': peer_ip,
                        'source': source,
                        'call_id': call_id,
                        'seq': SEQ_COUNTER,
                        'text': txt,
                        'start_ts': start_ts,
                        'end_ts': end_ts,
                        'wall_ts': datetime.utcnow().isoformat() + 'Z'
                    }
                    try:
                        ZMQ_QUEUE.put(evt, timeout=0.5)
                    except queue.Full:
                        rt_event('queue_full_drop', seq=SEQ_COUNTER)
            if st['chunks'] % PRINT_EVERY == 0:
                rt_event('chunk_progress_thread', peer_ip=peer_ip, source=source, call_id=st['call_id'],
                         chunks=st['chunks'], bytes=st['bytes'])
            if is_finished:
                # 保持旧的 call 结束日志
                dur_sec = (len(st['buffer'])/2)/8000.0
                rt_event('call_finished_thread', peer_ip=peer_ip, source=source, call_id=st['call_id'],
                         chunks=st['chunks'], bytes=st['bytes'], duration_sec=round(dur_sec,2))
                try:
                    ZMQ_QUEUE.put({
                        'evt': 'call_finished',
                        'peer_ip': peer_ip,
                        'source': source,
                        'call_id': st['call_id'],
                        'seq': SEQ_COUNTER,
                        'start_ts': start_ts,
                        'end_ts': end_ts,
                        'wall_ts': datetime.utcnow().isoformat() + 'Z'
                    }, timeout=0.5)
                except queue.Full:
                    rt_event('queue_full_drop', seq=SEQ_COUNTER)
                _rotate_call(peer_ip, source)
                del CALL_STATE[key]
        except Exception as e:
            rt_event('zmq_thread_error', error=str(e))
            time.sleep(0.05)
    try:
        sock.close(0)
        ctx.term()
    except Exception:
        pass
    rt_event('zmq_thread_exit')

async def _broadcast_loop():
    global BROADCAST_TASK, FORCE_DEBUG_ACTIVE_IP
    rt_event('broadcast_loop_start')
    try:
        loop = asyncio.get_event_loop()
        while not ZMQ_THREAD_STOP.is_set():
            try:
                evt = await loop.run_in_executor(None, ZMQ_QUEUE.get, True, 0.5)
            except queue.Empty:
                continue
            t_start = time.time()
            # FORCE debug: handle call finished to release active IP
            if FORCE_LISTENING_DEBUG and evt.get('evt') == 'call_finished':
                if FORCE_DEBUG_ACTIVE_IP == evt.get('peer_ip'):
                    rt_event('force_ip_released', ip=FORCE_DEBUG_ACTIVE_IP)
                    FORCE_DEBUG_ACTIVE_IP = None
                continue
            # 构造消息
            # evt 来自增量：区分 is_final / partial
            # 兼容：若无 segmentId 视为旧格式
            if evt.get('evt') == 'asr_incremental':
                asr_update = {
                    'type': 'asr_update',
                    'segmentId': evt.get('segmentId'),
                    'revision': evt.get('revision', 0),
                    'text': evt.get('text', ''),
                    'stable_len': evt.get('stable_len', 0),
                    'is_final': evt.get('is_final', False),
                    'peer_ip': evt.get('peer_ip'),
                    'source': evt.get('source'),
                    'call_id': evt.get('call_id'),
                    'sequence': evt.get('seq'),
                    'start_ts': evt.get('start_ts'),
                    'end_ts': evt.get('end_ts'),
                    'timestamp': evt.get('wall_ts')
                }
            else:
                asr_update = {
                    'type': 'asr_update',
                    'segmentId': f"legacy-{evt['seq']}",
                    'revision': 0,
                    'text': evt.get('text',''),
                    'stable_len': len(evt.get('text','')),
                    'is_final': True,
                    'peer_ip': evt.get('peer_ip'),
                    'source': evt.get('source'),
                    'call_id': evt.get('call_id'),
                    'sequence': evt.get('seq'),
                    'start_ts': evt.get('start_ts'),
                    'end_ts': evt.get('end_ts'),
                    'timestamp': evt.get('wall_ts')
                }
            # 只发送给对应IP的客户端（不再广播给所有客户端）
            target_ip = evt.get('peer_ip', 'unknown')
            tasks: List[asyncio.Task] = []
            target_clients = []
            clients_snapshot = list(LISTENING_CLIENTS.items())

            if FORCE_LISTENING_DEBUG:
                if FORCE_DEBUG_ACTIVE_IP is None:
                    FORCE_DEBUG_ACTIVE_IP = target_ip
                    rt_event('*******************force_pick_ip***************', ip=FORCE_DEBUG_ACTIVE_IP)
                target_ip = FORCE_DEBUG_ACTIVE_IP
            else:
                pass

            for cid, ws in clients_snapshot:
                if FORCE_LISTENING_DEBUG:
                    target_clients = clients_snapshot
                client_ip = CLIENT_IP_MAPPING.get(cid, 'unknown')
                if client_ip == target_ip:
                    target_clients.append((cid, ws))

            for cid, ws in target_clients:
                rt_event("send data to: ", cid)
                tasks.append(asyncio.create_task(ws.send_text(json.dumps(asr_update, ensure_ascii=False))))

            if not target_clients:
                rt_event('no_target_clients_found', target_ip=target_ip, 
                        total_clients=len(LISTENING_CLIENTS), 
                        available_ips=list(CLIENT_IP_MAPPING.values()))


            if tasks:
                results = await asyncio.gather(*tasks, return_exceptions=True)
                problem_clients: Set[str] = set()
                for idx, res in enumerate(results):
                    if isinstance(res, Exception) and idx < len(target_clients):
                        cid = target_clients[idx][0]
                        problem_clients.add(cid)
                        rt_event('client_send_error', client_id=cid, error=str(res))
                        
                # 清理有问题的客户端
                for pc in problem_clients:
                    LISTENING_CLIENTS.pop(pc, None)
                    CLIENT_IP_MAPPING.pop(pc, None)
                    rt_event('client_removed_send_fail', client_id=pc)
                    
            dur_ms = int((time.time() - t_start)*1000)
            rt_event('targeted_send', target_ip=target_ip, clients_found=len(target_clients), 
                    seq=evt.get('seq', 0), text_len=len(evt.get('text', '')), duration_ms=dur_ms)
    except asyncio.CancelledError:
        rt_event('broadcast_loop_cancel')
    except Exception as e:
        rt_event('broadcast_error', error=str(e))
    finally:
        rt_event('broadcast_loop_end')
        BROADCAST_TASK = None

def ensure_zmq_thread_started():
    global ZMQ_THREAD
    if ZMQ_THREAD and ZMQ_THREAD.is_alive():
        return
    ZMQ_THREAD_STOP.clear()
    ZMQ_THREAD = threading.Thread(target=_zmq_worker_thread, name='ZMQ-ASR-Thread', daemon=True)
    ZMQ_THREAD.start()
    rt_event('zmq_thread_started')


def ensure_broadcast_loop_started(reason: str = 'unspecified'):
    global BROADCAST_TASK
    if BROADCAST_TASK is None or BROADCAST_TASK.done():
        BROADCAST_TASK = asyncio.create_task(_broadcast_loop())
        rt_event('broadcast_loop_started', reason=reason)

@app.websocket("/listening")
async def websocket_listening_endpoint(websocket: WebSocket):
    """本机通话监听WebSocket端点 - 只向对应IP发送识别结果"""
    await websocket.accept()
    client_id = uuid.uuid4().hex[:8]
    
    # 获取客户端IP - 修复IP获取逻辑
    client_ip = "unknown"
    try:
        # 方法1: 从WebSocket对象获取
        if hasattr(websocket, 'client') and websocket.client:
            client_ip = websocket.client.host
        # 方法2: 从scope获取（FastAPI WebSocket）
        elif hasattr(websocket, 'scope') and websocket.scope.get('client'):
            client_ip = websocket.scope['client'][0]
        # 方法3: 从headers获取（处理代理情况）
        elif hasattr(websocket, 'headers'):
            x_forwarded_for = websocket.headers.get('x-forwarded-for')
            if x_forwarded_for:
                client_ip = x_forwarded_for.split(',')[0].strip()
            else:
                x_real_ip = websocket.headers.get('x-real-ip')
                if x_real_ip:
                    client_ip = x_real_ip
    except Exception as e:
        rt_event('ip_extraction_error', error=str(e))
    
    LISTENING_CLIENTS[client_id] = websocket
    CLIENT_IP_MAPPING[client_id] = client_ip  # 记录客户端IP映射
    
    ensure_zmq_thread_started()
    ensure_broadcast_loop_started(reason='client_fallback')
    rt_event('client_connect', client_id=client_id, client_ip=client_ip, total_clients=len(LISTENING_CLIENTS))
    connected_at = time.time()
    # 发送欢迎
    await websocket.send_text("监听服务已连接，正在等待通话数据...")
    await websocket.send_text(json.dumps({
        'type': 'listening_ready',
        'message': '监听服务已连接，正在等待通话数据...',
        'timestamp': datetime.now().isoformat()
    }, ensure_ascii=False))
    # 心跳任务（服务器每1s推一次）
    async def server_heartbeat():
        while True:
            try:
                await websocket.send_text(json.dumps({'type':'server_heartbeat','ts': datetime.utcnow().isoformat()+'Z'}))
                await asyncio.sleep(1.0)
            except Exception:
                break
    hb_task = asyncio.create_task(server_heartbeat())
    try:
        while True:
            try:
                data = await asyncio.wait_for(websocket.receive_text(), timeout=2.0)
            except asyncio.TimeoutError:
                continue
            except WebSocketDisconnect:
                break
            except Exception as e:
                rt_event('client_recv_error', client_id=client_id, error=str(e))
                break
            # 处理客户端消息
            try:
                msg = json.loads(data)
            except Exception:
                continue
            mtype = msg.get('type')
            if mtype == 'ping':
                await websocket.send_text(json.dumps({'type':'pong','ts': datetime.utcnow().isoformat()+'Z'}))
                rt_event('client_ping', client_id=client_id)
            elif mtype == 'stop_listening':
                await websocket.send_text(json.dumps({'type':'stopped','ts': datetime.utcnow().isoformat()+'Z'}))
                break
    finally:
        hb_task.cancel()
        LISTENING_CLIENTS.pop(client_id, None)
        CLIENT_IP_MAPPING.pop(client_id, None)  # 同时清理IP映射
        rt_event('client_disconnect', client_id=client_id, client_ip=client_ip, 
                duration_sec=round(time.time()-connected_at,2), remaining=len(LISTENING_CLIENTS))

# Global kill-switch to always ASR and broadcast to ALL sockets.
# Can be set via env (FORCE_LISTENING_SWITCH=1) or assigned in code.


if __name__ == "__main__":
    log.info("========================================")
    log.info("Voice Chat Backend with ASR - v2.0.0")
    log.info("调试模式 - 详细日志已启用")
    log.info("========================================")
    log.info("ASR模型状态: 已加载并可用")
    log.info(f"ASR模型: {MODEL_NAME} (rev: {MODEL_REV})")
    log.info(f"设备: {DEVICE}")
    log.info(f"音频参数: CHUNK_SIZE={CHUNK_SIZE}, ENC_LB={ENC_LB}, DEC_LB={DEC_LB}")
    log.info(f"帧大小: {STRIDE_SIZE} samples ({BYTES_PER_FRAME} bytes)")
    log.info("服务端点:")
    log.info("  - API文档: http://localhost:8000/docs")
    log.info("  - 健康检查: http://localhost:8000/health")
    log.info("  - ASR信息: http://localhost:8000/asr/info")
    log.info("  - 聊天API示例: http://localhost:8000/chat/list?id=user_001")
    log.info("WebSocket端点:")
    log.info("  - 聊天: ws://localhost:8000/chatting?id=chat_active_001")
    log.info("  - 本机监听 (ZMQ+ASR): ws://localhost:8000/listening")
    log.info("========================================")
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="debug"  # 设置为debug级别
    )